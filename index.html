<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Virtual Printer 3D</title>
  <style>
    body {
      background: #08151d;
      font-family: 'Courier New', monospace;
      margin: 0;
      overflow: hidden;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
    }

    .ui-overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #fff;
      z-index: 10;
      pointer-events: none;
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 2em;
      letter-spacing: 2px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
    }

    .status {
      color: #888;
      font-size: 14px;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
    }

    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    .controls button {
      background: #444;
      color: #fff;
      border: 1px solid #666;
      padding: 10px 20px;
      margin: 0 10px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      transition: all 0.3s;
    }

    .controls button:hover {
      background: #555;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
    }

    .instructions {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 12px;
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <div class="ui-overlay">
    <h1>lilRoby Virtual Printer</h1>
    <div class="status" id="status">Connecting...</div>
  </div>

  <div class="instructions">
    Drag to rotate • Scroll to zoom • Right-click to pan
  </div>

  <div class="controls">
    <button onclick="clearAllPrints()">Clear All Prints</button>
  </div>

  <div id="canvas-container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const statusEl = document.getElementById('status');
    const container = document.getElementById('canvas-container');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08151d);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(4, 3, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 2;
    controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2;

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 10, 5);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 50;
    mainLight.shadow.camera.left = -10;
    mainLight.shadow.camera.right = 10;
    mainLight.shadow.camera.top = 10;
    mainLight.shadow.camera.bottom = -10;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight.position.set(-5, 5, -5);
    scene.add(fillLight);

    const pointLight = new THREE.PointLight(0x00ff00, 0.3);
    pointLight.position.set(0, 2, 0);
    scene.add(pointLight);

    const planeGeometry = new THREE.PlaneGeometry(20, 20);
    const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
    const groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    groundPlane.rotation.x = -Math.PI / 2;
    groundPlane.position.y = -0.5;
    groundPlane.receiveShadow = true;
    scene.add(groundPlane);

    let printerModel = null;
    let printerOutputHeight = 0;

    const loader = new GLTFLoader();
    loader.load('./models/97029.glb', 
      function(gltf) {
        printerModel = gltf.scene;
        
        printerModel.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        const box = new THREE.Box3().setFromObject(printerModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        
        printerModel.position.x = -center.x;
        printerModel.position.y = -box.min.y;
        printerModel.position.z = -center.z;
        
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 2.5 / maxDim;
        printerModel.scale.set(scale, scale, scale);
        
        printerOutputHeight = box.max.y * scale - 0.3;
        
        scene.add(printerModel);
        controls.target.set(0, printerOutputHeight / 2, 0);
        controls.update();
        
        statusEl.textContent = 'Printer loaded - Connecting...';
      }, 
      undefined,
      function(error) {
        console.error('Error loading model:', error);
        statusEl.textContent = 'Failed to load 3D model - Connecting...';
      }
    );

    const printQueue = [];
    const stackedPapers = [];
    let currentPrintingPaper = null;

    class PrintPaper {
      constructor(data) {
        this.data = data;
        this.progress = 0;
        this.targetProgress = 1;
        this.settled = false;
        
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 700;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          ctx.drawImage(img, 20, 20, canvas.width - 40, 300);
          
          ctx.fillStyle = '#000000';
          ctx.font = 'bold 32px Courier New';
          if (data.title) {
            this.wrapText(ctx, data.title, 20, 350, canvas.width - 40, 40);
          }
          
          ctx.fillStyle = '#333333';
          ctx.font = '24px Courier New';
          let yPos = data.title ? 430 : 350;
          
          if (data.message) {
            this.wrapText(ctx, data.message, 20, yPos, canvas.width - 40, 32);
            yPos += 100;
          }
          
          if (data.name) {
            ctx.font = 'italic 24px Courier New';
            ctx.fillText('— ' + data.name, 20, yPos);
            yPos += 50;
          }
          
          if (data.print_id) {
            ctx.fillStyle = '#666666';
            ctx.font = '24px Courier New';
            ctx.fillText('Print #' + data.print_id, 20, yPos + 30);
          }
          
          this.texture.needsUpdate = true;
        };
        img.src = `http://wokki20.nl/lilroby/api/v1/prints/${data.unique_image_id}.webp`;
        
        this.texture = new THREE.CanvasTexture(canvas);
        this.texture.minFilter = THREE.LinearFilter;
        
        const geometry = new THREE.PlaneGeometry(1.4, 1.9);
        const material = new THREE.MeshStandardMaterial({ 
          map: this.texture,
          side: THREE.DoubleSide,
          roughness: 0.8,
          metalness: 0.1
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        this.mesh.position.y = printerOutputHeight;
        this.mesh.rotation.x = Math.PI / 2;
        
        scene.add(this.mesh);
      }
      
      wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(' ');
        let line = '';
        let currentY = y;
        
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + ' ';
          const metrics = ctx.measureText(testLine);
          const testWidth = metrics.width;
          
          if (testWidth > maxWidth && i > 0) {
            ctx.fillText(line, x, currentY);
            line = words[i] + ' ';
            currentY += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, currentY);
      }
      
      update(deltaTime) {
        if (this.settled) return;
        
        if (this.progress < this.targetProgress) {
          this.progress += deltaTime * 0.15;
          
          if (this.progress >= this.targetProgress) {
            this.progress = this.targetProgress;
            this.settled = true;
          }
          
          const dropDistance = 1.9 * this.progress;
          this.mesh.position.y = printerOutputHeight - dropDistance;
          
          const tilt = Math.sin(this.progress * Math.PI) * 0.05;
          this.mesh.rotation.x = Math.PI / 2 + tilt;
          
          const stackHeight = stackedPapers.length * 0.01;
          if (this.mesh.position.y < -0.4 + stackHeight) {
            this.mesh.position.y = -0.4 + stackHeight;
          }
        }
      }
      
      destroy() {
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.texture.dispose();
      }
    }

    function startPrinting(data) {
      if (currentPrintingPaper) return;
      
      currentPrintingPaper = new PrintPaper(data);
      
      setTimeout(() => {
        if (currentPrintingPaper) {
          stackedPapers.push(currentPrintingPaper);
          currentPrintingPaper = null;
          
          if (printQueue.length > 0) {
            const nextData = printQueue.shift();
            startPrinting(nextData);
          }
        }
      }, 7000);
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      
      if (currentPrintingPaper) {
        currentPrintingPaper.update(delta);
      }
      
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function loadPrints() {
      const stored = localStorage.getItem('lilroby_prints');
      return stored ? JSON.parse(stored) : [];
    }

    function savePrints(prints) {
      localStorage.setItem('lilroby_prints', JSON.stringify(prints));
    }

    function displayStoredPrints() {
      const prints = loadPrints();
      prints.forEach((printData, index) => {
        const paper = new PrintPaper(printData);
        paper.progress = 1;
        paper.targetProgress = 1;
        paper.settled = true;
        
        const stackHeight = index * 0.01;
        paper.mesh.position.y = -0.4 + stackHeight;
        paper.mesh.rotation.x = Math.PI / 2;
        
        stackedPapers.push(paper);
      });
    }

    window.clearAllPrints = function() {
      if (confirm('Are you sure you want to clear all prints?')) {
        localStorage.removeItem('lilroby_prints');
        
        stackedPapers.forEach(paper => paper.destroy());
        stackedPapers.length = 0;
        
        if (currentPrintingPaper) {
          currentPrintingPaper.destroy();
          currentPrintingPaper = null;
        }
        
        printQueue.length = 0;
        
        statusEl.textContent = 'All prints cleared';
        setTimeout(() => {
          statusEl.textContent = 'Connected';
        }, 2000);
      }
    }

    displayStoredPrints();
  </script>

  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
  <script>
    const socket = io('https://lilroby-printing.onrender.com');

    socket.on('connect', () => {
      console.log('Connected to Socket.IO');
      document.getElementById('status').textContent = 'Connected';
    });

    socket.on('new_data', (data) => {
      console.log('New print received:', data);
      
      const stored = localStorage.getItem('lilroby_prints');
      const prints = stored ? JSON.parse(stored) : [];
      prints.unshift(data);
      localStorage.setItem('lilroby_prints', JSON.stringify(prints));

      window.dispatchEvent(new CustomEvent('new-print', { detail: data }));

      document.getElementById('status').textContent = `New print received: #${data.print_id}`;
      setTimeout(() => {
        document.getElementById('status').textContent = 'Connected';
      }, 3000);
    });

    socket.on('disconnect', () => {
      console.log('Disconnected from Socket.IO');
      document.getElementById('status').textContent = 'Disconnected - Reconnecting...';
    });

    setInterval(() => {
      socket.emit('request-new-image', 'Requesting new image');
    }, 10000);

    window.addEventListener('new-print', (event) => {
      const printQueue = window.printQueue || [];
      const currentPrintingPaper = window.currentPrintingPaper;
      
      if (!currentPrintingPaper) {
        window.dispatchEvent(new CustomEvent('start-print', { detail: event.detail }));
      } else {
        printQueue.push(event.detail);
      }
    });
  </script>

  <script type="module">
    window.addEventListener('start-print', (event) => {
      import('./script.js').then(module => {
        if (typeof startPrinting !== 'undefined') {
          startPrinting(event.detail);
        }
      });
    });
  </script>

</body>
</html>
