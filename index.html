<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Virtual Printer 3D</title>
  <style>
    body {
      background: #08151d;
      font-family: 'Courier New', monospace;
      margin: 0;
      overflow: hidden;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
    }

    .ui-overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #fff;
      z-index: 10;
      pointer-events: none;
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 2em;
      letter-spacing: 2px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
    }

    .status {
      color: #888;
      font-size: 14px;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
    }

    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    .controls button {
      background: #444;
      color: #fff;
      border: 1px solid #666;
      padding: 10px 20px;
      margin: 0 10px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      transition: all 0.3s;
    }

    .controls button:hover {
      background: #555;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
    }

    .instructions {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 12px;
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }

    .debug {
      position: absolute;
      top: 100px;
      left: 20px;
      color: #0f0;
      font-size: 11px;
      font-family: monospace;
      z-index: 10;
      pointer-events: none;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>

  <div class="ui-overlay">
    <h1>lilRoby Virtual Printer</h1>
    <div class="status" id="status">Connecting...</div>
  </div>

  <div class="instructions">
    Drag to rotate • Scroll to zoom • Right-click to pan
  </div>

  <div class="controls">
    <button onclick="clearAllPrints()">Clear All Prints</button>
    <button onclick="toggleDebug()">Toggle Debug</button>
  </div>

  <div class="debug" id="debug" style="display: none;"></div>

  <div id="canvas-container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const statusEl = document.getElementById('status');
    const debugEl = document.getElementById('debug');
    const container = document.getElementById('canvas-container');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08151d);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(3, 2, 4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 1;
    controls.maxDistance = 10;
    controls.target.set(0, 0.5, 0);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 1);
    mainLight.position.set(3, 5, 3);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
    fillLight.position.set(-3, 3, -3);
    scene.add(fillLight);

    const pointLight = new THREE.PointLight(0x00ff00, 0.5);
    pointLight.position.set(0, 1.5, 0);
    scene.add(pointLight);

    const planeGeometry = new THREE.PlaneGeometry(20, 20);
    const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
    const groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    groundPlane.rotation.x = -Math.PI / 2;
    groundPlane.position.y = -0.5;
    groundPlane.receiveShadow = true;
    scene.add(groundPlane);

    const axesHelper = new THREE.AxesHelper(2);
    scene.add(axesHelper);

    const centerMarker = new THREE.Mesh(
      new THREE.SphereGeometry(0.05),
      new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    centerMarker.position.set(0, 0, 0);
    scene.add(centerMarker);

    let printerModel = null;
    let printerOutputPoint = new THREE.Vector3(0, 1.2, 0);
    let printerGroup = new THREE.Group();
    scene.add(printerGroup);

    const loader = new GLTFLoader();
    
    statusEl.textContent = 'Loading 3D model...';
    
    loader.load('./models/LilRoby1zu1.stl.gltf', 
      function(gltf) {
        printerModel = gltf.scene;
        
        console.log('Model loaded successfully');
        console.log('Model structure:', printerModel);
        
        printerModel.traverse((child) => {
          console.log('Child:', child.name, child.type);
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            console.log('Mesh found:', child.name);
            console.log('Material:', child.material);
            if (child.material) {
              if (child.material.map) {
                child.material.map.encoding = THREE.sRGBEncoding;
                console.log('Texture found on:', child.name);
              }
              child.material.needsUpdate = true;
            }
          }
        });

        const box = new THREE.Box3().setFromObject(printerModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        
        console.log('Bounding box min:', box.min);
        console.log('Bounding box max:', box.max);
        console.log('Center:', center);
        console.log('Size:', size);
        
        printerModel.position.set(-center.x, -center.y, -center.z);
        
        printerGroup.add(printerModel);
        printerGroup.position.set(0, 0.5, 0);
        
        const maxDim = Math.max(size.x, size.y, size.z);
        const targetSize = 1.5;
        const scale = targetSize / maxDim;
        printerGroup.scale.set(scale, scale, scale);
        
        console.log('Scale:', scale);
        console.log('Printer group position:', printerGroup.position);
        
        const boxHelper = new THREE.BoxHelper(printerGroup, 0x00ff00);
        scene.add(boxHelper);
        
        const finalBox = new THREE.Box3().setFromObject(printerGroup);
        printerOutputPoint.y = finalBox.max.y;
        
        console.log('Final output point:', printerOutputPoint);
        
        const outputMarker = new THREE.Mesh(
          new THREE.SphereGeometry(0.05),
          new THREE.MeshBasicMaterial({ color: 0x0000ff })
        );
        outputMarker.position.copy(printerOutputPoint);
        scene.add(outputMarker);
        
        statusEl.textContent = 'Printer loaded - Connecting...';
        
        updateDebugInfo();
      }, 
      function(progress) {
        if (progress.total > 0) {
          const percent = (progress.loaded / progress.total * 100).toFixed(0);
          statusEl.textContent = `Loading model: ${percent}%`;
          console.log('Loading progress:', percent + '%');
        }
      },
      function(error) {
        console.error('Error loading model:', error);
        statusEl.textContent = 'Failed to load 3D model - Using fallback';
        
        const fallbackGeometry = new THREE.BoxGeometry(1, 0.8, 0.6);
        const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const fallbackPrinter = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
        fallbackPrinter.position.y = 0.5;
        fallbackPrinter.castShadow = true;
        fallbackPrinter.receiveShadow = true;
        scene.add(fallbackPrinter);
        
        printerOutputPoint.y = 0.9;
      }
    );

    const paperStrip = {
      sections: [],
      totalHeight: 0
    };

    class PaperSection {
      constructor(data, yOffset) {
        this.data = data;
        this.yOffset = yOffset;
        this.height = 2.0;
        this.segments = 20;
        
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 700;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const imgHeight = 250;
          const imgWidth = canvas.width - 40;
          const imgX = (canvas.width - imgWidth) / 2;
          ctx.drawImage(img, imgX, 20, imgWidth, imgHeight);
          
          ctx.textAlign = 'center';
          
          ctx.fillStyle = '#000000';
          ctx.font = 'bold 32px Courier New';
          let yPos = 300;
          if (data.title) {
            this.wrapTextCentered(ctx, data.title, canvas.width / 2, yPos, canvas.width - 40, 40);
            yPos += 80;
          }
          
          ctx.fillStyle = '#333333';
          ctx.font = '24px Courier New';
          
          if (data.message) {
            this.wrapTextCentered(ctx, data.message, canvas.width / 2, yPos, canvas.width - 40, 32);
            yPos += 100;
          }
          
          if (data.name) {
            ctx.font = 'italic 24px Courier New';
            ctx.fillText('— ' + data.name, canvas.width / 2, yPos);
            yPos += 50;
          }
          
          if (data.print_id) {
            ctx.fillStyle = '#666666';
            ctx.font = '24px Courier New';
            ctx.fillText('Print #' + data.print_id, canvas.width / 2, yPos + 20);
          }
          
          this.texture.needsUpdate = true;
        };
        img.src = `http://wokki20.nl/lilroby/api/v1/prints/${data.unique_image_id}.webp`;
        
        this.texture = new THREE.CanvasTexture(canvas);
        this.texture.minFilter = THREE.LinearFilter;
        
        const geometry = new THREE.PlaneGeometry(1.0, this.height, 1, this.segments);
        const material = new THREE.MeshStandardMaterial({ 
          map: this.texture,
          side: THREE.DoubleSide,
          roughness: 0.9,
          metalness: 0.05
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        
        this.vertices = [];
        this.velocities = [];
        
        for (let i = 0; i <= this.segments; i++) {
          this.vertices.push({
            x: 0,
            y: printerOutputPoint.y - (i / this.segments) * this.height,
            z: 0
          });
          this.velocities.push({ x: 0, y: 0, z: 0 });
        }
        
        scene.add(this.mesh);
      }
      
      wrapTextCentered(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(' ');
        let line = '';
        let currentY = y;
        
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + ' ';
          const metrics = ctx.measureText(testLine);
          const testWidth = metrics.width;
          
          if (testWidth > maxWidth && i > 0) {
            ctx.fillText(line, x, currentY);
            line = words[i] + ' ';
            currentY += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, currentY);
      }
      
      simulate(deltaTime) {
        const gravity = -9.8;
        const damping = 0.98;
        const groundY = -0.5;
        
        this.vertices[0].x = printerOutputPoint.x;
        this.vertices[0].y = printerOutputPoint.y;
        this.vertices[0].z = printerOutputPoint.z;
        this.velocities[0] = { x: 0, y: 0, z: 0 };
        
        for (let i = 1; i <= this.segments; i++) {
          this.velocities[i].y += gravity * deltaTime;
          
          this.vertices[i].x += this.velocities[i].x * deltaTime;
          this.vertices[i].y += this.velocities[i].y * deltaTime;
          this.vertices[i].z += this.velocities[i].z * deltaTime;
          
          this.velocities[i].x *= damping;
          this.velocities[i].y *= damping;
          this.velocities[i].z *= damping;
          
          if (this.vertices[i].y < groundY) {
            this.vertices[i].y = groundY;
            this.velocities[i].y = 0;
            this.velocities[i].x *= 0.8;
            this.velocities[i].z *= 0.8;
          }
        }
        
        for (let iter = 0; iter < 3; iter++) {
          for (let i = 1; i <= this.segments; i++) {
            const prev = this.vertices[i - 1];
            const curr = this.vertices[i];
            
            const dx = curr.x - prev.x;
            const dy = curr.y - prev.y;
            const dz = curr.z - prev.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            const targetDist = this.height / this.segments;
            
            if (dist > 0) {
              const diff = (dist - targetDist) / dist;
              const offsetX = dx * diff * 0.5;
              const offsetY = dy * diff * 0.5;
              const offsetZ = dz * diff * 0.5;
              
              if (i > 1) {
                this.vertices[i - 1].x += offsetX;
                this.vertices[i - 1].y += offsetY;
                this.vertices[i - 1].z += offsetZ;
              }
              
              curr.x -= offsetX;
              curr.y -= offsetY;
              curr.z -= offsetZ;
            }
          }
        }
        
        const posAttr = this.mesh.geometry.attributes.position;
        for (let i = 0; i <= this.segments; i++) {
          const idx = i * 2;
          posAttr.setXYZ(idx, -0.5, this.vertices[i].y, this.vertices[i].z);
          posAttr.setXYZ(idx + 1, 0.5, this.vertices[i].y, this.vertices[i].z);
        }
        posAttr.needsUpdate = true;
        this.mesh.geometry.computeVertexNormals();
      }
      
      destroy() {
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.texture.dispose();
      }
    }

    function addPrint(data) {
      const section = new PaperSection(data, paperStrip.totalHeight);
      paperStrip.sections.push(section);
      paperStrip.totalHeight += section.height;
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      
      const delta = Math.min(clock.getDelta(), 0.033);
      
      paperStrip.sections.forEach(section => {
        section.simulate(delta);
      });
      
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function loadPrints() {
      const stored = localStorage.getItem('lilroby_prints');
      return stored ? JSON.parse(stored) : [];
    }

    function savePrints(prints) {
      localStorage.setItem('lilroby_prints', JSON.stringify(prints));
    }

    function displayStoredPrints() {
      const prints = loadPrints();
      prints.reverse().forEach((printData, index) => {
        setTimeout(() => {
          addPrint(printData);
        }, index * 100);
      });
    }

    function updateDebugInfo() {
      if (printerGroup) {
        const info = `
Printer Position: ${printerGroup.position.x.toFixed(2)}, ${printerGroup.position.y.toFixed(2)}, ${printerGroup.position.z.toFixed(2)}
Printer Scale: ${printerGroup.scale.x.toFixed(2)}
Output Point: ${printerOutputPoint.x.toFixed(2)}, ${printerOutputPoint.y.toFixed(2)}, ${printerOutputPoint.z.toFixed(2)}
Camera: ${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}
Papers: ${paperStrip.sections.length}
        `;
        debugEl.innerHTML = info.trim();
      }
    }

    setInterval(updateDebugInfo, 100);

    window.toggleDebug = function() {
      debugEl.style.display = debugEl.style.display === 'none' ? 'block' : 'none';
    }

    window.clearAllPrints = function() {
      if (confirm('Are you sure you want to clear all prints?')) {
        localStorage.removeItem('lilroby_prints');
        
        paperStrip.sections.forEach(section => section.destroy());
        paperStrip.sections = [];
        paperStrip.totalHeight = 0;
        
        statusEl.textContent = 'All prints cleared';
        setTimeout(() => {
          statusEl.textContent = 'Connected';
        }, 2000);
      }
    }

    window.addNewPrint = function(data) {
      addPrint(data);
    }

    setTimeout(() => {
      displayStoredPrints();
    }, 500);
  </script>

  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
  <script>
    const socket = io('https://lilroby-printing.onrender.com');

    socket.on('connect', () => {
      console.log('Connected to Socket.IO');
      document.getElementById('status').textContent = 'Connected';
    });

    socket.on('new_data', (data) => {
      console.log('New print received:', data);
      
      const stored = localStorage.getItem('lilroby_prints');
      const prints = stored ? JSON.parse(stored) : [];
      prints.unshift(data);
      localStorage.setItem('lilroby_prints', JSON.stringify(prints));

      if (typeof window.addNewPrint === 'function') {
        window.addNewPrint(data);
      }

      document.getElementById('status').textContent = `New print received: #${data.print_id}`;
      setTimeout(() => {
        document.getElementById('status').textContent = 'Connected';
      }, 3000);
    });

    socket.on('disconnect', () => {
      console.log('Disconnected from Socket.IO');
      document.getElementById('status').textContent = 'Disconnected - Reconnecting...';
    });

    setInterval(() => {
      socket.emit('request-new-image', 'Requesting new image');
    }, 10000);
  </script>

</body>
</html>
