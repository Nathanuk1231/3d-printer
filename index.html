<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Virtual Printer 3D</title>
  <style>
    body {
      background: #08151d;
      font-family: 'Courier New', monospace;
      margin: 0;
      overflow: hidden;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
    }

    .ui-overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #fff;
      z-index: 10;
      pointer-events: none;
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 2em;
      letter-spacing: 2px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
    }

    .status {
      color: #888;
      font-size: 14px;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
    }

    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    .controls button {
      background: #444;
      color: #fff;
      border: 1px solid #666;
      padding: 10px 20px;
      margin: 0 10px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      transition: all 0.3s;
    }

    .controls button:hover {
      background: #555;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
    }

    .instructions {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      color: #666;
      font-size: 12px;
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <div class="ui-overlay">
    <h1>lilRoby Virtual Printer</h1>
    <div class="status" id="status">Connecting...</div>
  </div>

  <div class="instructions">
    Drag to rotate • Scroll to zoom • Right-click to pan
  </div>

  <div class="controls">
    <button onclick="clearAllPrints()">Clear All Prints</button>
  </div>

  <div id="canvas-container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const statusEl = document.getElementById('status');
    const container = document.getElementById('canvas-container');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08151d);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 2;
    controls.maxDistance = 15;
    controls.target.set(0, 0, 0);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 1);
    mainLight.position.set(5, 10, 5);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 50;
    mainLight.shadow.camera.left = -10;
    mainLight.shadow.camera.right = 10;
    mainLight.shadow.camera.top = 10;
    mainLight.shadow.camera.bottom = -10;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
    fillLight.position.set(-5, 5, -5);
    scene.add(fillLight);

    const pointLight = new THREE.PointLight(0x00ff00, 0.4);
    pointLight.position.set(0, 3, 0);
    scene.add(pointLight);

    const planeGeometry = new THREE.PlaneGeometry(30, 30);
    const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
    const groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    groundPlane.rotation.x = -Math.PI / 2;
    groundPlane.position.y = -2;
    groundPlane.receiveShadow = true;
    scene.add(groundPlane);

    let printerModel = null;

    const loader = new GLTFLoader();
    loader.load('./models/97029.glb', 
      function(gltf) {
        printerModel = gltf.scene;
        
        printerModel.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            if (child.material) {
              child.material.needsUpdate = true;
            }
          }
        });

        printerModel.position.set(0, 0, 0);
        printerModel.scale.set(3, 3, 3);
        
        scene.add(printerModel);
        
        statusEl.textContent = 'Printer loaded - Connecting...';
      }, 
      undefined,
      function(error) {
        console.error('Error loading model:', error);
        statusEl.textContent = 'Failed to load 3D model - Connecting...';
      }
    );

    const printQueue = [];
    const paperStrip = {
      sections: [],
      totalHeight: 0
    };

    class PaperSection {
      constructor(data, yOffset) {
        this.data = data;
        this.yOffset = yOffset;
        this.height = 2.0;
        
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 700;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const imgHeight = 250;
          const imgWidth = canvas.width - 40;
          const imgX = (canvas.width - imgWidth) / 2;
          ctx.drawImage(img, imgX, 20, imgWidth, imgHeight);
          
          ctx.textAlign = 'center';
          
          ctx.fillStyle = '#000000';
          ctx.font = 'bold 32px Courier New';
          let yPos = 300;
          if (data.title) {
            this.wrapTextCentered(ctx, data.title, canvas.width / 2, yPos, canvas.width - 40, 40);
            yPos += 80;
          }
          
          ctx.fillStyle = '#333333';
          ctx.font = '24px Courier New';
          
          if (data.message) {
            this.wrapTextCentered(ctx, data.message, canvas.width / 2, yPos, canvas.width - 40, 32);
            yPos += 100;
          }
          
          if (data.name) {
            ctx.font = 'italic 24px Courier New';
            ctx.fillText('— ' + data.name, canvas.width / 2, yPos);
            yPos += 50;
          }
          
          if (data.print_id) {
            ctx.fillStyle = '#666666';
            ctx.font = '24px Courier New';
            ctx.fillText('Print #' + data.print_id, canvas.width / 2, yPos + 20);
          }
          
          this.texture.needsUpdate = true;
        };
        img.src = `http://wokki20.nl/lilroby/api/v1/prints/${data.unique_image_id}.webp`;
        
        this.texture = new THREE.CanvasTexture(canvas);
        this.texture.minFilter = THREE.LinearFilter;
        
        const geometry = new THREE.PlaneGeometry(1.4, this.height);
        const material = new THREE.MeshStandardMaterial({ 
          map: this.texture,
          side: THREE.DoubleSide,
          roughness: 0.9,
          metalness: 0.05
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        this.mesh.position.set(0, 1.5 - yOffset, 0);
        
        scene.add(this.mesh);
      }
      
      wrapTextCentered(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(' ');
        let line = '';
        let currentY = y;
        
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + ' ';
          const metrics = ctx.measureText(testLine);
          const testWidth = metrics.width;
          
          if (testWidth > maxWidth && i > 0) {
            ctx.fillText(line, x, currentY);
            line = words[i] + ' ';
            currentY += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, currentY);
      }
      
      updatePosition(yOffset) {
        this.yOffset = yOffset;
        this.mesh.position.y = 1.5 - yOffset;
      }
      
      destroy() {
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.texture.dispose();
      }
    }

    let animatingNewPrint = false;
    let animationProgress = 0;

    function addPrint(data) {
      const section = new PaperSection(data, paperStrip.totalHeight);
      paperStrip.sections.push(section);
      paperStrip.totalHeight += section.height;
      
      animatingNewPrint = true;
      animationProgress = 0;
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      
      if (animatingNewPrint) {
        animationProgress += delta * 0.5;
        
        if (animationProgress >= 1) {
          animationProgress = 1;
          animatingNewPrint = false;
        }
        
        const targetOffset = paperStrip.totalHeight - 2;
        const currentOffset = targetOffset * animationProgress;
        
        paperStrip.sections.forEach((section, index) => {
          const baseOffset = paperStrip.sections.slice(0, index).reduce((sum, s) => sum + s.height, 0);
          section.updatePosition(baseOffset - currentOffset);
        });
      }
      
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function loadPrints() {
      const stored = localStorage.getItem('lilroby_prints');
      return stored ? JSON.parse(stored) : [];
    }

    function savePrints(prints) {
      localStorage.setItem('lilroby_prints', JSON.stringify(prints));
    }

    function displayStoredPrints() {
      const prints = loadPrints();
      prints.reverse().forEach((printData) => {
        const section = new PaperSection(printData, paperStrip.totalHeight);
        paperStrip.sections.push(section);
        paperStrip.totalHeight += section.height;
      });
      
      if (paperStrip.sections.length > 0) {
        const targetOffset = paperStrip.totalHeight - 2;
        paperStrip.sections.forEach((section, index) => {
          const baseOffset = paperStrip.sections.slice(0, index).reduce((sum, s) => sum + s.height, 0);
          section.updatePosition(baseOffset - targetOffset);
        });
      }
    }

    window.clearAllPrints = function() {
      if (confirm('Are you sure you want to clear all prints?')) {
        localStorage.removeItem('lilroby_prints');
        
        paperStrip.sections.forEach(section => section.destroy());
        paperStrip.sections = [];
        paperStrip.totalHeight = 0;
        
        printQueue.length = 0;
        animatingNewPrint = false;
        animationProgress = 0;
        
        statusEl.textContent = 'All prints cleared';
        setTimeout(() => {
          statusEl.textContent = 'Connected';
        }, 2000);
      }
    }

    window.addNewPrint = function(data) {
      addPrint(data);
    }

    displayStoredPrints();
  </script>

  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
  <script>
    const socket = io('https://lilroby-printing.onrender.com');

    socket.on('connect', () => {
      console.log('Connected to Socket.IO');
      document.getElementById('status').textContent = 'Connected';
    });

    socket.on('new_data', (data) => {
      console.log('New print received:', data);
      
      const stored = localStorage.getItem('lilroby_prints');
      const prints = stored ? JSON.parse(stored) : [];
      prints.unshift(data);
      localStorage.setItem('lilroby_prints', JSON.stringify(prints));

      if (typeof window.addNewPrint === 'function') {
        window.addNewPrint(data);
      }

      document.getElementById('status').textContent = `New print received: #${data.print_id}`;
      setTimeout(() => {
        document.getElementById('status').textContent = 'Connected';
      }, 3000);
    });

    socket.on('disconnect', () => {
      console.log('Disconnected from Socket.IO');
      document.getElementById('status').textContent = 'Disconnected - Reconnecting...';
    });

    setInterval(() => {
      socket.emit('request-new-image', 'Requesting new image');
    }, 10000);
  </script>

</body>
</html>
